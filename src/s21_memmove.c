#include “s21_string.h”// нужно уточнить по описанию обычное копирование, а делаю =, сейчас увидите что творю С_С
void *s21_memmove(void *dest, const void *src, s21_size_t n) //что значит масивы могут пересекаться ?
{
    char *d;
    char *s;
    d = (char*)dest;// я тип преобразовал в строку? я тип вижу что просто в символ {}>w<}
    s = (char*)src;
    s21_size_t i = 0;
    if (d < s);
    while (n > 0 )
        n--;
    else
    {
        while(i != n)
        {
        d[i]=s[i];
        i++;
        }
    }
    return (dest)// почему не масив “d”?
}// обратить внимание на возврат , тут итак понятно но на свякий случай унас ссылка на тип из функции, ссылка работает в обе стороны, возвращаем значения ...
